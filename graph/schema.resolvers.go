package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.22

import (
	"context"
	"fmt"

	"github.com/ryuji-cre8ive/huyou-server/db"
	"github.com/ryuji-cre8ive/huyou-server/graph/model"
)

// CreateShopItem is the resolver for the createShopItem field.
func (r *mutationResolver) CreateShopItem(ctx context.Context, title string, description *string, image *string, price int, isContainDelivery bool, userID string) (*model.ShopItem, error) {
	auth := &db.Auth{
		Mail:     "random",
		Password: "random",
	}

	id := auth.GenerateRandomHash()

	shopItem := &model.ShopItem{
		ID:                id,
		Title:             title,
		Description:       description,
		UserID:            userID,
		Price:             price,
		IsContainDelivery: isContainDelivery,
		Image:             image,
	}
	r.DB.Create(&shopItem)
	return shopItem, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, mail string, password string) (*model.User, error) {
	auth := &db.Auth{
		Mail:     mail,
		Password: password,
	}

	hasedPassword, err := auth.HashPassword()
	if err != nil {
		return nil, err
	}

	id := auth.GenerateRandomHash()

	user := &model.User{
		ID:       id,
		Mail:     mail,
		Password: hasedPassword,
	}

	r.DB.Create(&user)
	fmt.Printf("user was created! %+v\n", user)
	return user, nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, input model.NewComment) (*model.Comment, error) {
	comment := &model.Comment{
		ID:         input.ID,
		Content:    input.Content,
		UserID:     input.UserID,
		ShopItemID: input.ShopItemID,
	}
	r.DB.Create(&comment)
	fmt.Printf("comment was created! %+v\n", comment)
	return comment, nil
}

// Items is the resolver for the items field.
func (r *queryResolver) Items(ctx context.Context) ([]*model.ShopItem, error) {
	items := make([]*model.ShopItem, 0)
	r.DB.Find(&items)
	fmt.Printf("items data: %+v\n", *items[0])
	return items, nil
}

// Item is the resolver for the item field.
func (r *queryResolver) Item(ctx context.Context, id string) (*model.ShopItem, error) {
	var item *model.ShopItem
	if err := r.DB.Where("id = (?)", id).Limit(20).First(&item).Error; err != nil {
		return nil, err
	}
	fmt.Printf("shopItem: %+v\n", item)
	return item, nil
}

// Comments is the resolver for the comments field.
func (r *queryResolver) Comments(ctx context.Context) ([]*model.Comment, error) {
	comments := make([]*model.Comment, 0)
	r.DB.Find(&comments)
	return comments, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	user := make([]*model.User, 0)
	r.DB.Limit(5).Find(&user)
	return user, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	var user *model.User
	r.DB.Debug().Where("id = (?)", id).Find(&user)
	return user, nil
}

// UserWithMail is the resolver for the userWithMail field.
func (r *queryResolver) UserWithMail(ctx context.Context, mail string, password string) (*model.User, error) {
	var user *model.User
	result := r.DB.Where("mail = ?", mail).First(&user)
	if result.Error != nil {
		return nil, result.Error
	}

	auth := db.Auth{
		Mail:     mail,
		Password: password,
	}

	hashedPassword := auth.CheckPasswordHash(password, user.Password)
	if !hashedPassword {
		return nil, nil
	}

	return user, nil
}

// User is the resolver for the user field.
func (r *shopItemResolver) User(ctx context.Context, obj *model.ShopItem) (*model.User, error) {
	var user *model.User
	r.DB.Debug().Where("id = (?)", obj.UserID).Find(&user)
	return user, nil
}

// ShopItem is the resolver for the ShopItem field.
func (r *userResolver) ShopItem(ctx context.Context, obj *model.User) ([]*model.ShopItem, error) {
	items := make([]*model.ShopItem, 0)
	r.DB.Debug().Where("user_id = (?)", obj.ID).Find(&items)
	return items, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// ShopItem returns ShopItemResolver implementation.
func (r *Resolver) ShopItem() ShopItemResolver { return &shopItemResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type shopItemResolver struct{ *Resolver }
type userResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *shopItemResolver) IsContainDelivery(ctx context.Context, obj *model.ShopItem) (bool, error) {
	panic(fmt.Errorf("not implemented: IsContainDelivery - isContainDelivery"))
}
func (r *shopItemResolver) Price(ctx context.Context, obj *model.ShopItem) (int, error) {
	panic(fmt.Errorf("not implemented: Price - price"))
}
